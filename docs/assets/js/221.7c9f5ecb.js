(window.webpackJsonp=window.webpackJsonp||[]).push([[221],{616:function(t,a,r){"use strict";r.r(a);var i=r(10),s=Object(i.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"特质-trait"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特质-trait"}},[t._v("#")]),t._v(" 特质 trait")]),t._v(" "),a("p",[t._v("trait 是对未知类型 Self 定义的方法集。该类型也可以访问同一个 trait 中定义的 其他方法。")]),t._v(" "),a("h2",{attrs:{id:"派生"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#派生"}},[t._v("#")]),t._v(" 派生")]),t._v(" "),a("p",[t._v("通过 #[derive] 属性，编译器能够提供某些 trait 的基本实现。如果 需要更复杂的行为，这些 trait 也可以手动实现。")]),t._v(" "),a("ul",[a("li",[t._v("比较 trait: Eq, PartialEq, Ord, PartialOrd")]),t._v(" "),a("li",[t._v("Clone, 用来从 &T 创建副本 T。")]),t._v(" "),a("li",[t._v("Copy，使类型具有 “复制语义”（copy semantics）而非 “移动语义”（move semantics）。")]),t._v(" "),a("li",[t._v("Hash，从 &T 计算哈希值（hash）。")]),t._v(" "),a("li",[t._v("Default, 创建数据类型的一个空实例。")]),t._v(" "),a("li",[t._v("Debug，使用 {:?} formatter 来格式化一个值。")])])])}),[],!1,null,null,null);a.default=s.exports}}]);